{% extends 'base.html.twig' %}

{% block title %}Report{% endblock %}

{% block body %}
    <div class="container">
        <h1>Course Report</h1>
        <div class="image-container">
            <img src="{{ asset('images/report-cover.jpeg') }}" alt="Report Cover">
        </div>
        <br>

        <nav>
            <ul>
                <li><a href="#kmom01">Kmom01</a></li>
                <li><a href="#kmom02">Kmom02</a></li>
                <li><a href="#kmom03">Kmom03</a></li>
                <li><a href="#kmom04">Kmom04</a></li>
                <li><a href="#kmom05">Kmom05</a></li>
                <li><a href="#kmom06">Kmom06</a></li>
                <li><a href="#kmom10">Kmom10</a></li>
            </ul>
        </nav>

        <section id="kmom01">
            <h2>Kmom01</h2>
            
            <h3>Berätta kort om dina förkunskaper och tidigare erfarenheter kring objektorientering.</h3>
            <p>
                När det gäller objektorientering så har jag läst ungefär 100 böcker kring programmering och datavetenskap senaste året, många av vilka inkluderade kapitel om objektorientering.
                Utöver detta har jag försökt applicera objektorientering i de projekt jag skrivit för egen användning i Python.
                Sedan har objektorientering applicerats under de olika kurserna som jag har tagit.
            </p>
            
            <h3>Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver veta/förstå för att kunna komma igång och skapa sina första klasser?</h3>
            <p>
                Det man behöver känna till är väl det generella att en klass är ett recept för objekt och ett objekt är en instans av en klass.
                En klass kan ha attribut och metoder där attribut innehåller värden och metoder innehåller processer/beteenden.
                Man bör väl också känna till skillnaden och innebörden av publika och privata attribut/metoder.
                T.ex. att man vill hålla sig till privata så mycket som möjligt. Eftersom att externa användare av en klass blir beroende på klassens publika metoder/attribut och dessa är inga man kan kontrollera. Så det är viktigt att det som är publikt har en låg sannolikhet att behöva förändras.
            </p>
            
            <h3>Reflektera kort över den kodbas, koden, strukturen som användes till uppgiften me/report, hur uppfattar du den?</h3>
            <p>
                Personligen så gillar jag att minimera externa dependencies, och gillar därför språk som t.ex. Python med ett rejält basbibliotek där man kan utveckla väldigt mycket utan att behöver comitta till ett specifikt framework.
                Jag blir lite nervös av en massa mappar och filer som genereras av ramverk, i alla fall om det är ett personligt projekt som jag vet att jag kommer jobba på i månader/år framöver.
                Men i slutändan går det inte att undvika vid utveckling av komplicerade webbappar tänker jag.
                Men gällande kodbasen för denna uppgift så är den än så länge indelad i Controller och View (templates mappen). Dock så finns det väl inte riktigt en separat Model-del än så länge.
                Jag ser fram emot att arbeta med MVC-modellen i kursen då jag försökt applicera tänket för ett interface för ett av mina personliga projekt.
            </p>
            
            <h3>Med tanke på artikeln “PHP The Right Way”, vilka delar in den finner du extra intressanta och värdefulla? Är det några särskilda områden som du känner att du vill veta mer om? Lyft fram några delar av artikeln som du känner mer värdefulla.</h3>
            <p>
                När det gäller strategi så tycker jag att SOLID är intressant och vill bli duktig på att förstå och applicera dessa principer.
            </p>
            
            <h3>Vilken är din TIL för detta kmom?</h3>
            <p>
                TIL för denna kmom är att komma igång med ett Symphony projekt med MVC-design (dock utan Model än så länge).
            </p>
        </section>

        <section id="kmom02">
            <h2>Kmom02</h2>
                <h3>Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.</h3>
                    <p>
                        Arv fungerar så att en subklass ärver metoder och attribut från en superklass. PHP nyttjar single inheritance snarare än multiple inheritance. Vid komposition så "har" en klass en annan klass medans en klass "är" också en annan klass vid arv (t.ex. subklassen chihuahua är superklassen hund medans en hund, alltså superklassen, har ben, alltså komposition). Man kan också dela in composition i typer, t.ex. komposition (ena klassen fungerar inte utan den andra) och aggregering (de funkar ihop men kan existera separat).
                        När det gäller begreppet "interface" så har jag ganska länge försökt förstå detta begrepp. En definition av begreppet är ungefär att en klass interface består av de publika metoder/attribut som en klass har, och ibland specifikt de som är definierade av en klass abstrakta basklass. Den senare kan likställas med ett "kontrakt" som klassen efterlever (etablerandet av kontraktet är just syftet med den abstrakta klassen, vilken inte innehåller konkreta implementeringar/implementationsdetaljer).
                        Vad som fortfarande är lite otydligt för mig är om en metods parametrar är den metodens "interface", eller om termen inte används på det sättet.
                        Man kan väl möjligtvis säga då att interface i en bredare betydelse är det som ett objekt visar utåt (parametrar, metoder, attribut), ungefär som celler i kroppen har vissa "tillåtna" sätt att interface:a med cellen som t.ex. vissa virus utnyttjar.
                        Traits vet jag inte om jag förstått men det låter som "mixins" ungefär, alltså någonting som kan användas för att förlänga en klass med metoder. Likt mixins så verkar traits inte kunna existera självständigt. Båda är i alla fall flexibla sätt att "extend:a" (förlänga) klasser med metoder.
                    </p>
                <h3>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?</h3>
                    <p>
                        Jag implementerade tre klasser: Card som representerar ett enskilt kort, varje med en färg ("suit") och värde. DeckOfCards representerar en kortlek och har diverse metoder för att initialisera/ställa om, blanda, dra, sortera etc. Slutligen har jag en klass CardHand som representerar handen med de dragna korten.
                        I CardController så implementerar jag rutter för deck, shuffle, draw och draw_multiple. Jag skapar metod ensureDeckExists för återanvändning av initialiseringslogik.
                        Jag implementerar session och session/delete rutter för lättare debugging. Jag lägger till alla rutter till en Card Game-sida, vilken fungerar som en landningssida. Jag skapar ett UML-diagram med PlantUML och beskriver klasserna på landningssidan.
                        Jag implementerar diverse saker såsom t.ex. en inputruta där man kan välja antal kort man vill dra.
                        Jag går vidare till andra sektionen av krav och implementerar en JsonApiController som innehåller rutter för deck, shuffle, draw och draw_multiple för API-landningssidan.
                        Jag ser till att förändringar via API och Card Game-sidan båda fungerar bra med session och visar sina uppdateringar på Session-sidan.
                        När det gäller förbättringar så tänker jag dels tester, för att minimera manuell testning (blir viktigare ju större projekten blir, hur mer saker är couplat etc.).
                        Jag kanske också bör convertera tillbaka till textbeskrivningen av "färgerna" vid API-requests istället för att visa UTF-8 koden för "färgen".
                        Hade väl varit coolt att implementera någon animation när man drar kort, som flyttar korten ner till "Previously Drawn Cards".
                    </p>
                <h3>Vilka är dina reflektioner så här långt med att jobb i Symfony med applikationskod enligt MVC?</h3>
                    <p>
                        Jag tycker Symfony ger en ganska tydlig struktur och arbetssätt enligt MVC. När projektet väl är uppe så fungerar det, men det känns som att det är många detaljer (många config-ställen, externa dependencies etc.), jämfört med t.ex. att starta ett Django-projekt enligt MVC (dock har jag inte full insikt i Django ännu så kan vara en överdrift).
                        Jag tyckte det var lite jobbigt med debugging än så länge, men det finns ju dev.log filen man kan logga till samt flashmeddelanden osv.
                    </p>
                <h3>Vilken är din TIL för detta kmom?</h3>
                    <p>
                        Att hantera session i Symfony, specifikt hålla ett konsekvent "state" över flera interaktioner. Vidare intressant med JSON-API, vilket är lovande för framtida appliceringar i olika sammanhang. 
                        Jag funderar på om dessa är REST-ful, om inte annat vill jag lära mig att skapa REST-ful API:er så man kan t.ex. ha en backend med olika frontends (mobilapp, webb etc.)
                    </p>
        </section>

        <section id="kmom03">
            <h2>Kmom03</h2>
            <h3>Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?</h3>
                <p>
                    Jag tycker det är bra för att få en idé kring hur logiken kan se ut i slutändan men samtidigt att man bör nog förhålla sig lite flexibelt till sin planering, eftersom det kan komma upp saker man inte tänkt på i förväg och så vidare. Jag tänker att man kan se det som att man etablerar en arbetshypotes kring en fungerande implementering som man sedan testar och itererar på om nödvändigt.
                    Jag tänker att det kan också sänka den upplevda kognitiva belastningen i stunden för att man har ett extern kognitivt stöd (diagram, lista på klasser/metoder, implementeringslogik/psuedokod etc.) som man kan hänvisa till.
                </p>
            <h3>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?</h3>
                <p>
                    Jag började med att lägga till landningssidan och placeholder templates för doc, home (landningssida), start (dit man kommer om man klickar starta spel) samt ordnade jag en grundläggande GameController.
                    Sedan genomförde jag problemlösningskravet. 
                    I nästa steg så implementerade jag klasserna som definierats i problemlösningssteget, alltså Bank, Game och Player. Jag använde tidigare implementerade klasser Card, CardHand och DeckOfCards.
                    Game-klassen hanterar spelflödet. Player-klassen representerar en spelare och hanterar dennes hand och handlingar. Bank-klassen hanterar banken, dennes kort samt dennes handlingar. 
                    Jag uppdaterade CardHand att hantera ess enligt tjugoett-reglerna. Jag skapade play och result templates som visas under spelet respektive när spelet är slut.
                    Jag är rätt nöjd med indelningen i de klasser jag har.
                    Jag hade kunnat förbättra själva stylingen/gränssnittet till att se lite mer tilltalande ut.
                    Jag tycker att serialiseringslösningen/konvertering till och från array blev lite väl komplicerad och hade kunnat refaktorisera detta till att bli enklare så att förlängning av kodbasen blir lättare i en (hypotetisk) vidareutveckling av applikationen.
                </p>
            <h3>Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?</h3>
                <p>
                    Det finns saker jag gillar och gillar mindre. Det jag gillar är att det finns en tydlig indelning i templates, Entity, Controller, public/assets, tools osv. Alltså att det underlättar och uppmuntrar till ett arkitekturtänk. Jag tycker fortfarande att debugging i Symfony är lite jobbigt.
                </p>
            <h3>Vilken är din TIL för detta kmom?</h3>
                <p>
                    TIL för detta kmom är nog ökad insikt i nyttan av planering i form av flödesdiagram, klasslistor, psuedokod med mera.
                </p>
        </section>

        <section id="kmom04">
            <h2>Kmom04</h2>
            <h3>Berätta hur du upplevde att skriva kod som testar annan kod med PHPUnit och hur du upplever phpunit rent allmänt.</h3>
                <p>
                    Jag gillar principen med testning, alltså att det sänker kostnaden/den psykologiska barriären för att refaktorera/ändra/göra tillägg till kodbasen.
                    Sedan tänker jag att vissa enhetstest är ganska onödiga och att man nog vill hitta en balans, där man fokuserar på viktigare enhetstest (t.ex. med fokus på sådant som förmodligen kan ändras i framtiden).
                    Sedan att det är så mätbart tycker jag är coolt och användbart.
                </p>
            <h3>Hur väl lyckades du med kodtäckningen av din kod, lyckades du nå mer än 90% kodtäckning?</h3>
                <p>
                    Jag lyckades nå cirka 90 % kodtäckning. Jag missar lite på "classes and traits" vilket jag inte riktigt förstår vad som syftas på.
                </p>
            <h3>Upplever du din egen kod som “testbar kod” eller finns det delar i koden som är mer eller mindre testbar och finns det saker som kan göras för att förbättra kodens testbarhet?</h3>
                <p>
                    Jag tycker att koden är till största del testbar, eftersom den är till stor del indelad i mindre metoder.
                    I allmänhet är det väl kod som är starkt "coupled", som har externa beroenden, som täcker mer än en uppgift per funktion/metod och kod som har komplext kontrollflöde som är svårare att enhetstesta.
                    Vissa typer av kod kanske till och med har så många möjliga utfall att det inte går att testa alla möjliga utfall (det är på sätt och vis "intractable" i alla fall i ett testningssammanhang)
                </p>
            <h3>Valde du att skriva om delar av din kod för att förbättra den eller göra den mer testbar, om så berätta lite hur du tänkte.</h3>
                <p>
                    Jag hade en statisk metod som min linter inte gillade att jag testade så jag skapade en icke-statisk version.
                    Utöver det så undvek jag att ändra på saker i kodbasen.
                </p>
            <h3>Fundera över om du anser att testbar kod är något som kan identifiera “snygg och ren kod”.</h3>
                <p>
                    Jag tänker att testbar kod och snygg/ren kod överlappar ganska mycket. Både bör vara begränsade i ansvarsfördelning (t.ex. en metod per diskret uppgift), och vara återanvändbar/modulär, förlängningsbar etc.
                    Jag tänker väl dels att i båda fallen så vill man skriva kod som minimerar behovet av att skriva om testkod.
                    Alltså om kodbasen kan förlängas (utan att kräva stora förändringar via sidoeffekter) så är underhållningskostnaderna för enhetstester mindre. 
                </p>
            <h3>Vilken är din TIL för detta kmom?</h3>
                <p>
                    TIL för detta kmom är hur enhetstester fungerar i praktiken när man jobbar med PHP/Symfony.
                </p>
        </section>

        <section id="kmom05">
            <h2>Kmom05</h2>
            <h3>Gick det bra att jobba igenom övningen med Symfony och Doctrine. Något särskilt du tänkte/reagerade på under övningen?</h3>
                <p>
                    Det gick bra. Intressant med att man skapar filer genom att svara på frågor. Enkel integration med SQLite var trevligt.
                </p>
            <h3>Berätta om din applikation och hur du tänkte när du byggde upp den. Tänkte du något speciellt på användargränssnittet?</h3>
                <p>
                    Det är en biblioteksapplikation med CRUD-funktionalitet. Det finns en landningssida där man ser alla böcker i biblioteket.
                    Därifrån kan man göra olika saker. Man kan visa mer information om en given bok, man kan redigera information om en bok, 
                    man kan lägga till en ny bok, man kan reset:a databasen och man kan ta bort böcker.

                    När det gäller applikationen i allmänhet och användargränssnittet i synnerhet så tänkte jag vilken grundläggande funktionalitet och utseende jag skulle vilja ha om jag använde sidan 
                    för att hålla kolla på vilka böcker jag själv läst. Det ska vara lätt att lägga till böcker, redigera, ta bort osv.

                    När jag byggde upp den så tänkte jag på att separera ansvar i olika templates, routes osv.
                </p>
            <h3>Gick det bra att jobba med ORM i CRUD eller vad anser du om det, jämför gärna med andra sätt att jobba med databaser?</h3>
                <p>
                    Det kändes rätt smidigt. I tidigare databaskurs tycker jag det var jobbigt med att inte kunna jobba direkt/enbart i IDE utan man fick hålla på med massa detaljer i konsol eller annat verktyg.
                </p>
            <h3>Vad är din uppfattning om ORM så här långt och relatera gärna till andra sätt att jobba med applikationskod mot databaser?</h3>
                <p>
                    Vad jag förstått kring ORM är att det har fördelar när det gäller att minska beroende/coupling till ett specifikt databassystem, vissa ORM kan hantera olika databassystem t.ex.
                    En nackdel är väl möjligtvis att man kanske har mindre detaljkontroll i vissa fall eftersom ORM utgör en högre nivå av abstraktion över SQL-koden.
                    En annan fördel tänker jag att det blir mindre fram och tillbaka mellan olika utvecklingsmiljöer (e.g. databasverktyg och IDE) utan man kan hålla sig till samma miljö och arbeta med båda.
                </p>
            <h3>Vilken är din TIL för detta kmom?</h3>
                <p>
                    TIL för detta kmom är definitivt grundläggande förståelse av och användning av ORM.
                </p>
        </section>

        <section id="kmom06">
            <h2>Kmom06</h2>
            <h3>Hur uppfattade du verktyget phpmetrics och fann du några särskilda bitar mer värdefulla än andra? Var det några särskilda metrics eller bilder du uppskattade?</h3>
                <p>
                    Jag tyckte det var intressant att man kunde få data om coupling, komplexitet osv. på det sättet.
                    Samtidigt så tänker jag att det inte finns något som säger att en viss komplexitet är bättre än någon annan på ett sätt med tanke på att mer inkapsling och bättre läsbarhet kan innebära mer kod, mer metoder etc. vilket kan öka komplexitetsmetrics.
                    Men det ger en indikation på vilka klasser man kan kolla närmare på och jag tänker att man därifrån kan individualisera utifrån klassen i fråga och vad man tycker är rimligt och vad som motsvarar bäst "trade off".
                    Alltså att dessa mer objektiva metrics ger en indikation på var man kan testa mer subjektivt (t.ex. hur läsbar upplevs koden, hur lätt upplevs det att ändra i koden osv.) och sen utifrån sina subjektiva metrics bestämmer vad som är bäst att göra.
                </p>
            <h3>Berätta hur det gick att integrera med Scrutinizer och vilken är din första känsla av verktyget och dess badges? Vilken kodtäckning och kodkvalitet fick du efter första bygget?</h3>
                <p>
                    Det gick bra att integrera ned Scrutinizer till att börja med men senare fick jag lite problem vid build där jag var tvungen att ändra i gitignore filen för att få med build-mappen samt databasfilen.
                    Jag fick en bra score redan från början på kodkvalitet (10.0) men endast +20 % täckning.

                </p>
            <h3>Hur är din egen syn på kodkvalitet, berätta lite om den? Tror du man kan man påvisa kodkvalitet i någon viss mån med badges eller vad tror du?</h3>
                <p>
                    Jag tänker väl att det ger en indikation eller sannolikhetsindikator på hur bra kodkvaliteten är utifrån de specifika saker som mäts. Men man får väl vara medveten om vad som inte mäts också, så man inte tror att verktygen mäter någonting som de egentligen inte mäter.
                </p>
            <h3>Vilken är din TIL för detta kmom?</h3>
                <p>
                    TIL för detta kmom är att det finns sådana här verktyg och att det finns olika sätt att jobba med refaktorisering och förbättring av kodkvalitet och kodtäckning.
                </p>
        </section>

        <section id="kmom10">
            <h2>Kmom10</h2>
            <h3>För varje krav du implementerat, dvs 1-3, 4, 5, 6, skriver du ett textstycke om ca 5-10 meningar där du beskriver hur du löste kravet. Poängsättningen tar sin start i din text så se till att skriva väl för att undvika poängavdrag. Missar du att skriva/dokumentera din lösning så blir det 0 poäng. Du kan inte komplettera en inlämning för att få högre betyg.</h3>
                <p>
                    Jag valde kortspelet som projekt och valde att fokusera på Black Jack med fokus på de riktiga reglerna, att kunna spela 1-3 händer, att kunna registrera sig och satsa pengar etc. Jag valde att länka till projektet i navbaren, vilket tar en till en sida med annan design (enligt krav) men också med en “Back”-knapp i denna sidans navbar så man kan gå fram och tillbaka mellan huvudsidan och projektsidan. Här finns en Register, About och Play sida (tillgängliga i navbar). I Register så registrerar man namn och banksaldo. I About så kan man läsa om spelregler och projektet. I Play så väljer man vadsumma samt hur många händer man vill spela. När man trycker Start Game så startar spelet. Vadsumman multipliceras med antalet händer, så om vadsumman är 100 och man spelar tre händer så blir det 300. Om man vinner med 2 händer och förlorar med 1 så vinner man +200 minus -100 vilket blir +100 till saldot. Spelaren informeras i gränssnittet om man har “bustat”, “stannat”  och spelet är slut när alla händer har stannat eller “bustat”. Till Gitrepot så kompletterade jag den ursprungliga README.md filen i huvudprojektet med en innehållsförteckning där man kan navigera mellan information om huvudprojekt samt kmom10 projektet. Badges finns och all information enligt kraven. Innehållet i docs är uppdaterat och kodtäckning för Entity/Proj är 100 %. Dock visar badges 74 % coverage, förmodligen eftersom den också räknar på Controllers. Jag implementerade inga optionella krav.
                </p>
            <h3>Skriv ett allmänt stycke om hur projektet gick att genomföra. Problem/lösningar/strul/enkelt/svårt/snabbt/lång tid, etc. Var projektet lätt eller svårt? Tog det lång tid? Vad var svårt och vad gick lätt? Var det ett bra och rimligt projekt för denna kursen?</h3>
                <p>
                    Projektet var utmanande och tog ganska lång tid. Jag tyckte det var utmanande att få till att samtliga händer fungerade som de skulle när det gäller play/stay/bust beteenden när man spelar flera händer. Vidare så hade jag problem med att få vadsumman (“bet amount”) att fungera korrekt utifrån hur många händer som vann/förlorade. Jag valde att beräkna saldot efter spelet är slut där vinster och förluster plusas ihop och läggs till saldot. Överlag tyckte jag att projektet, i alla fall Black Jack-kortspelet, var utmanande men ändå rimligt projektarbete. 
                </p>
            <h3>Avsluta med ett sista stycke med dina tankar om kursen och vad du anser om materialet och handledningen (ca 5-10 meningar). Ge feedback till lärarna och förslå eventuella förbättringsförslag till kommande kurstillfällen. Är du nöjd/missnöjd? Kommer du att rekommendera kursen till dina vänner/kollegor? På en skala 1-10, vilket betyg ger du kursen?</h3>
                <p>
                    Överlag så har det varit en intressant och utmanande kurs. Jag har använt Discord-kurshistoriken flitigt för att hitta lösningar på problem jag stött på, därav kan man säga att handledning varit till stor hjälp i det avseendet. Bra föreläsningar också och bra respons på Discord. Jag skulle ge kursen 8 eller 9 av 10, med kommentaren “mycket lärorikt”. Jag är nöjd med andra ord. Jag skulle definitivt rekommendera kursen till programmeringsnyfikna kompisar! Jag har inga särskilda förbättringsförslag till denna kursen. Fortsätt med bra respons i Discord, och bra struktur att det mesta utfördes i Report-mappen. 
                </p>
        </section>
    </div>
{% endblock %}
